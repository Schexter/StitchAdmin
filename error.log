# StitchAdmin 2.0 - Error Log

**Erstellt von Hans Hahn - Alle Rechte vorbehalten**

Dieses Protokoll dokumentiert alle Fehler, Probleme und deren LÃ¶sungen wÃ¤hrend der Entwicklung und im Betrieb von StitchAdmin 2.0.

---

## Format

```
[YYYY-MM-DD HH:MM:SS] SEVERITY: Kurzbeschreibung
Kategorie: [Module/Component]
Fehlercode: [Optional]

Beschreibung:
Detaillierte Fehlerbeschreibung

Ursache:
Was war die Ursache des Problems?

LÃ¶sung:
Wie wurde das Problem gelÃ¶st?

Verbesserung:
Was kann beim nÃ¤chsten Mal besser gemacht werden?

Betroffene Dateien:
- datei1.py
- datei2.py

Status: [OFFEN / IN ARBEIT / GELÃ–ST / VERSCHOBEN]
---
```

### Severity Levels
- ðŸ”´ **CRITICAL** - System funktionsunfÃ¤hig, Datenverlust mÃ¶glich
- ðŸŸ  **ERROR** - Feature funktioniert nicht, keine Datenverluste
- ðŸŸ¡ **WARNING** - Feature funktioniert eingeschrÃ¤nkt
- ðŸ”µ **INFO** - Hinweis, kein Fehler

---

## Error Log

### [2025-11-05 14:30:00] ðŸ”µ INFO: Projekt-Dokumentation initialisiert
Kategorie: [Dokumentation]

Beschreibung:
Error-Log-Datei wurde erstellt als Teil der Pflichtdateien-Initiative.

Ursache:
Fehlende Pflichtdateien gemÃ¤ÃŸ Custom Instructions.

LÃ¶sung:
README.md, TODO.md, CHANGELOG.md und error.log erstellt.

Verbesserung:
Bei neuen Projekten sofort alle Pflichtdateien anlegen.

Betroffene Dateien:
- error.log (neu)
- README.md (neu)
- TODO.md (neu)
- CHANGELOG.md (neu)

Status: GELÃ–ST
---

### [2025-11-05 12:00:00] ðŸŸ¡ WARNING: Python 3.13 KompatibilitÃ¤t
Kategorie: [Dependencies]

Beschreibung:
SQLAlchemy-Version < 2.0.36 funktioniert nicht mit Python 3.13.
Beim Start der Anwendung tritt folgender Fehler auf:
```
ImportError: cannot import name 'attrgetter' from 'operator'
```

Ursache:
Python 3.13 hat interne Ã„nderungen am `operator`-Modul, die Ã¤ltere SQLAlchemy-Versionen nicht unterstÃ¼tzen.

LÃ¶sung:
1. SQLAlchemy auf Version â‰¥2.0.36 aktualisiert
2. `fix_sqlalchemy.bat` erstellt fÃ¼r automatische Reparatur
3. `requirements.txt` aktualisiert: `SQLAlchemy>=2.0.36`

Verbesserung:
- Dependencies regelmÃ¤ÃŸig auf KompatibilitÃ¤t prÃ¼fen
- Bei Python-Updates Compatibility-Matrix checken
- Automatische Dependency-Updates mit Dependabot

Betroffene Dateien:
- requirements.txt
- fix_sqlalchemy.bat (neu)

Status: GELÃ–ST
---

### [2025-11-05 10:00:00] ðŸŸ¡ WARNING: Legacy-Controller noch vorhanden
Kategorie: [Code-QualitÃ¤t]

Beschreibung:
Nach der Migration zu DB-basierten Controllern existieren noch die alten JSON-basierten Controller im Projekt, was zu Verwirrung fÃ¼hrt und Code-Duplikation darstellt.

Ursache:
Migration wurde durchgefÃ¼hrt, aber alte Dateien nicht entfernt (als Referenz behalten).

LÃ¶sung:
Geplant fÃ¼r Meilenstein 1:
- Alle JSON-basierten Controller entfernen
- Nur DB-basierte Controller behalten
- Code-Review durchfÃ¼hren

Verbesserung:
Bei Migrationen klare Strategie:
1. Neue Version parallel entwickeln
2. Testing durchfÃ¼hren
3. Alte Version markieren (z.B. `.old` Suffix)
4. Nach erfolgreicher Migration alte Dateien lÃ¶schen

Betroffene Dateien:
- customer_controller.py (JSON-basiert)
- article_controller.py (JSON-basiert)
- order_controller.py (JSON-basiert)
- machine_controller.py (JSON-basiert)
- thread_controller.py (JSON-basiert)
- production_controller.py (JSON-basiert)
- shipping_controller.py (JSON-basiert)
- supplier_controller.py (JSON-basiert)

Status: OFFEN (Geplant fÃ¼r Meilenstein 1)
---

### [2025-11-04] ðŸŸ  ERROR: L-Shop Import Encoding-Problem
Kategorie: [Import/Export]

Beschreibung:
Beim Importieren von L-Shop Excel-Dateien werden Umlaute (Ã¤, Ã¶, Ã¼) falsch dargestellt.
Beispiel: "Baumwollstoff grÃ¼n" wird zu "Baumwollstoff grï¿½n"

Ursache:
Excel-Dateien werden nicht mit UTF-8 Encoding gespeichert, sondern mit Windows-1252 (ANSI).
openpyxl interpretiert die Dateien standardmÃ¤ÃŸig als UTF-8.

LÃ¶sung:
1. Encoding-Detection mit `chardet` implementiert
2. Automatische Encoding-Erkennung im Import-Prozess
3. Fallback auf `cp1252` (Windows-1252) wenn UTF-8 fehlschlÃ¤gt

Code-Ã„nderung in `article_controller_db.py`:
```python
import chardet

# Encoding erkennen
with open(file_path, 'rb') as f:
    result = chardet.detect(f.read())
    encoding = result['encoding']

# Mit erkanntem Encoding Ã¶ffnen
df = pd.read_excel(file_path, engine='openpyxl', encoding=encoding)
```

Verbesserung:
- Dokumentation fÃ¼r Benutzer: Excel-Dateien immer als UTF-8 speichern
- Encoding-Auswahl in UI anbieten
- Vorschau vor Import zeigen

Betroffene Dateien:
- src/controllers/article_controller_db.py

Status: GELÃ–ST
---

### [2025-11-03] ðŸŸ  ERROR: DST-Datei Upload schlÃ¤gt bei groÃŸen Dateien fehl
Kategorie: [File-Upload]

Beschreibung:
Upload von DST-Dateien > 10MB schlÃ¤gt fehl mit Fehler:
```
413 Request Entity Too Large
```

Ursache:
Flask's `MAX_CONTENT_LENGTH` ist standardmÃ¤ÃŸig auf 16MB gesetzt, aber Nginx (falls verwendet) hat oft ein niedrigeres Limit (1MB).

LÃ¶sung:
1. Flask-Konfiguration in `.env`:
```env
MAX_CONTENT_LENGTH=52428800  # 50MB
```

2. Nginx-Konfiguration (falls verwendet):
```nginx
client_max_body_size 50M;
```

3. Benutzer-Feedback verbessert: DateigrÃ¶ÃŸe vor Upload prÃ¼fen und anzeigen

Verbesserung:
- Upload mit Chunks fÃ¼r sehr groÃŸe Dateien (>50MB)
- Progress-Bar fÃ¼r Upload-Status
- Komprimierung der DST-Dateien prÃ¼fen

Betroffene Dateien:
- .env
- src/utils/design_upload.py
- nginx.conf (Produktion)

Status: GELÃ–ST
---

### [2025-11-02] ðŸŸ¡ WARNING: Datums-Filter in Order-Ãœbersicht inkonsistent
Kategorie: [Frontend/UI]

Beschreibung:
Datums-Filter in der Auftrags-Ãœbersicht zeigt teilweise falsche Ergebnisse.
Beispiel: Filter "Letzte 30 Tage" zeigt auch AuftrÃ¤ge von vor 45 Tagen.

Ursache:
JavaScript-Datums-Berechnung berÃ¼cksichtigt keine Zeitzonen.
Server gibt Datum in UTC zurÃ¼ck, aber Browser interpretiert in lokaler Zeit.

LÃ¶sung:
1. Alle Datumsangaben im Backend auf UTC normalisiert
2. Frontend konvertiert UTC zu Lokalzeit mit `moment.js`
3. Datums-Filter im Backend durchgefÃ¼hrt statt im Frontend

Code-Ã„nderung:
```python
# Backend (order_controller_db.py)
from datetime import datetime, timezone

# Immer UTC verwenden
order.created_at = datetime.now(timezone.utc)

# Filter
start_date = datetime.now(timezone.utc) - timedelta(days=30)
orders = Order.query.filter(Order.created_at >= start_date)
```

Verbesserung:
- Timezone-Awareness in allen Datums-Operationen
- Einheitliche Datums-Utilities erstellen
- Unit-Tests fÃ¼r Datums-Berechnungen

Betroffene Dateien:
- src/controllers/order_controller_db.py
- src/templates/orders/list.html
- src/static/js/date-utils.js

Status: IN ARBEIT
---

### [2025-11-01] ðŸ”µ INFO: Template-Pfade nach Migration angepasst
Kategorie: [Migration]

Beschreibung:
Nach der Migration von StitchAdmin zu StitchAdmin2.0 funktionierten einige Template-Pfade nicht mehr.

Ursache:
Templates wurden in `src/templates/` verschoben, aber einige Controller verwendeten noch alte Pfade.

LÃ¶sung:
1. Alle `render_template()` Aufrufe geprÃ¼ft
2. Pfade angepasst auf relative Pfade ab `src/templates/`
3. Template-Loader in `app.py` korrekt konfiguriert

Beispiel:
```python
# Alt
render_template('customer/list.html')

# Neu (korrekt)
render_template('customers/list.html')
```

Verbesserung:
- Template-Struktur dokumentieren
- Naming-Conventions festlegen
- Template-Tests implementieren

Betroffene Dateien:
- app.py
- Alle Controller-Dateien (38 Dateien)

Status: GELÃ–ST
---

## HÃ¤ufige Fehler & Quick Fixes

### 1. "Module not found" beim Import
**Ursache:** Import-Pfade nach Migration falsch  
**LÃ¶sung:** `from src.models.models import ...` statt `from models.models import ...`

### 2. "Database is locked"
**Ursache:** SQLite-DB wird von mehreren Prozessen gleichzeitig geÃ¶ffnet  
**LÃ¶sung:** Alle alten App-Instanzen schlieÃŸen, nur eine Instance laufen lassen

### 3. "Template not found"
**Ursache:** Template-Pfad falsch oder Datei nicht vorhanden  
**LÃ¶sung:** Pfad relativ zu `src/templates/` prÃ¼fen, GroÃŸ-/Kleinschreibung beachten

### 4. "CSRF Token missing"
**Ursache:** Flask-WTF CSRF-Schutz aktiv, aber Token fehlt im Formular  
**LÃ¶sung:** `{{ form.csrf_token }}` in jedes Formular einfÃ¼gen

### 5. "Werkzeug Version Conflict"
**Ursache:** Inkompatible Werkzeug-Version mit Flask 3.0  
**LÃ¶sung:** `pip install --upgrade Werkzeug>=3.0.0`

---

## Debug-Tipps

### Debug-Modus aktivieren
```bash
# In .env
FLASK_ENV=development
FLASK_DEBUG=1
```

### Datenbank-Queries loggen
```python
# In app.py
import logging
logging.basicConfig()
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)
```

### Template-Debugging
```html
<!-- Im Template -->
{{ debug() }}  <!-- Zeigt alle verfÃ¼gbaren Variablen -->
```

### Performance-Profiling
```python
from flask import Flask
from werkzeug.middleware.profiler import ProfilerMiddleware

app = Flask(__name__)
app.wsgi_app = ProfilerMiddleware(app.wsgi_app, restrictions=[30])
```

---

## Statistiken

### Fehler nach Kategorie (Stand: 05.11.2025)
- ðŸ”´ CRITICAL: 0
- ðŸŸ  ERROR: 2 (2 gelÃ¶st)
- ðŸŸ¡ WARNING: 3 (2 gelÃ¶st, 1 in Arbeit)
- ðŸ”µ INFO: 2

### Durchschnittliche LÃ¶sungszeit
- CRITICAL: N/A (keine kritischen Fehler)
- ERROR: ~2 Stunden
- WARNING: ~4 Stunden

---

## PrÃ¤ventive MaÃŸnahmen

### Implementiert
- âœ… Input-Validierung mit WTForms
- âœ… SQL-Injection-Schutz durch SQLAlchemy ORM
- âœ… CSRF-Schutz aktiviert
- âœ… Sichere Datei-Uploads mit Whitelist
- âœ… Fehler-Logging in Dateien

### Geplant
- [ ] Unit-Tests fÃ¼r alle Models (Meilenstein 1)
- [ ] Integration-Tests fÃ¼r Controller (Meilenstein 1)
- [ ] Error-Monitoring mit Sentry (Meilenstein 5)
- [ ] Automatische Backups (Meilenstein 3)
- [ ] Rate-Limiting fÃ¼r API (Meilenstein 3)

---

## Review-Schedule

Dieses Error-Log wird **tÃ¤glich** auf neue EintrÃ¤ge geprÃ¼ft und **wÃ¶chentlich** (jeden Freitag) reviewed.

**NÃ¤chster Review:** 08.11.2025  
**Verantwortlich:** Hans Hahn

---

**Erstellt von Hans Hahn - Alle Rechte vorbehalten**  
**Initialisiert:** 05.11.2025  
**Letzte Aktualisierung:** 05.11.2025
